#!/bin/bash
# 04-backup.sh - pgBackRest and WAL archiving setup
# Configures backup system and WAL archiving

# Set strict error handling
set -euo pipefail

# Source utility functions
source /opt/container/entrypoint.d/scripts/utils/logging.sh
source /opt/container/entrypoint.d/scripts/utils/validation.sh
source /opt/container/entrypoint.d/scripts/utils/security.sh

# Helper function to generate env command that removes all PGBACKREST environment variables
generate_clean_env_command() {
    local env_cmd="env"
    
    # Get all PGBACKREST_* environment variables and add them to the unset list
    while IFS='=' read -r var_name var_value; do
        if [[ "$var_name" =~ ^PGBACKREST_ ]]; then
            env_cmd="$env_cmd -u $var_name"
        fi
    done < <(env | grep '^PGBACKREST_')
    
    echo "$env_cmd"
}

# Helper function to run pgBackRest commands without problematic environment variables
run_pgbackrest() {
    # Create a clean environment by removing all PGBACKREST_* variables
    # This prevents conflicts between environment variables and config file settings
    local env_args=()
    
    # Get all PGBACKREST_* environment variables and add them to the unset list
    while IFS='=' read -r var_name var_value; do
        if [[ "$var_name" =~ ^PGBACKREST_ ]]; then
            env_args+=("-u" "$var_name")
        fi
    done < <(env | grep '^PGBACKREST_')
    
    # Run pgbackrest with a clean environment
    env "${env_args[@]}" pgbackrest "$@"
}

# Main function
main() {
    log_script_start "04-backup.sh"

    # Only proceed if backup is enabled
    if [ "${PGBACKREST_ENABLE:-false}" != "true" ]; then
        log_info "Backup not enabled, skipping backup setup"
        return 0
    fi

    # Validate environment before proceeding
    if ! validate_environment; then
        log_error "Environment validation failed"
        return 1
    fi

    # Configure pgBackRest
    configure_pgbackrest

    # Enable archiving in postgresql.conf
    enable_archiving

    # Note: Stanza creation is handled in the runtime phase when PostgreSQL is running
    # See startup.sh for stanza creation logic

    # Test backup connectivity (basic checks only)
    test_backup_connectivity

    log_script_end "04-backup.sh"
}

# Configure pgBackRest
# PGBACKREST_REPO_PATH: Override the default repo1-path for all repository types:
#   - posix/filesystem: Uses PGBACKREST_REPO_PATH or defaults to ${backup_dir}
#   - s3: Uses PGBACKREST_REPO_PATH or defaults to /pgbackrest
#   - gcs: Uses PGBACKREST_REPO_PATH or defaults to /pgbackrest
#   - azure: Uses PGBACKREST_REPO_PATH or defaults to /pgbackrest
#   - sftp: Uses PGBACKREST_REPO_PATH or defaults to /var/lib/pgbackrest
configure_pgbackrest() {
    log_info "Configuring pgBackRest"

    local backup_dir="${PGBACKUP:-/usr/local/pgsql/backup}"
    local data_dir="${PGDATA:-/usr/local/pgsql/data}"
    local config_file="/etc/pgbackrest.conf"
    # Get postgres user/group (with defaults)
    local POSTGRES_USER="${POSTGRES_USER:-postgres}"
    local POSTGRES_GROUP="${POSTGRES_GROUP:-postgres}"
    # Backward compatibility: accept legacy *REPO1_* variable names if new generic names not provided
    local repo1_type="${PGBACKREST_REPO_TYPE:-${PGBACKREST_REPO1_TYPE:-posix}}"
    local repo1_path_override="${PGBACKREST_REPO_PATH:-${PGBACKREST_REPO1_PATH:-}}" # Optional explicit override
    local retention_full="${PGBACKREST_REPO_RETENTION_FULL:-${PGBACKREST_REPO1_RETENTION_FULL:-2}}"
    local retention_diff="${PGBACKREST_REPO_RETENTION_DIFF:-${PGBACKREST_REPO1_RETENTION_DIFF:-6}}"

    # Create pgBackRest configuration
    cat > "$config_file" << EOF
# pgBackRest configuration generated by container
[global]
repo1-retention-full=${retention_full}
repo1-retention-diff=${retention_diff}
log-level-console=info
log-level-file=debug
log-path=${backup_dir}/log
lock-path=${backup_dir}/lock
spool-path=${backup_dir}/spool

# Repository 1 configuration
repo1-type=${repo1_type}
EOF

    # If posix (filesystem) repository, set path (prefer override if provided)
    if [ "${repo1_type}" = "posix" ] || [ "${repo1_type}" = "filesystem" ]; then
        if [ -n "$repo1_path_override" ]; then
            echo "repo1-path=${repo1_path_override}" >> "$config_file"
        else
            echo "repo1-path=${backup_dir}" >> "$config_file"
        fi
    elif [ "$repo1_type" = "s3" ]; then
        # Map S3-specific environment variables to pgBackRest configuration if provided
        # Required: bucket & endpoint (validated elsewhere)
        [ -n "${PGBACKREST_REPO_S3_BUCKET:-${PGBACKREST_REPO1_S3_BUCKET:-}}" ] && echo "repo1-s3-bucket=${PGBACKREST_REPO_S3_BUCKET:-${PGBACKREST_REPO1_S3_BUCKET}}" >> "$config_file"
        [ -n "${PGBACKREST_REPO_S3_ENDPOINT:-${PGBACKREST_REPO1_S3_ENDPOINT:-}}" ] && echo "repo1-s3-endpoint=${PGBACKREST_REPO_S3_ENDPOINT:-${PGBACKREST_REPO1_S3_ENDPOINT}}" >> "$config_file"
        [ -n "${PGBACKREST_REPO_S3_REGION:-${PGBACKREST_REPO1_S3_REGION:-}}" ] && echo "repo1-s3-region=${PGBACKREST_REPO_S3_REGION:-${PGBACKREST_REPO1_S3_REGION}}" >> "$config_file"
        [ -n "${PGBACKREST_REPO_S3_KEY:-${PGBACKREST_REPO1_S3_KEY:-}}" ] && echo "repo1-s3-key=${PGBACKREST_REPO_S3_KEY:-${PGBACKREST_REPO1_S3_KEY}}" >> "$config_file"
        [ -n "${PGBACKREST_REPO_S3_KEY_SECRET:-${PGBACKREST_REPO1_S3_KEY_SECRET:-}}" ] && echo "repo1-s3-key-secret=${PGBACKREST_REPO_S3_KEY_SECRET:-${PGBACKREST_REPO1_S3_KEY_SECRET}}" >> "$config_file"
        if [ -n "${PGBACKREST_REPO_S3_VERIFY_TLS:-}" ]; then
            local verify_tls_val
            case "${PGBACKREST_REPO_S3_VERIFY_TLS}" in
                true|TRUE|1|y|Y) verify_tls_val="y" ;;
                false|FALSE|0|n|N) verify_tls_val="n" ;;
                *) verify_tls_val="y" ;; # default safe
            esac
            echo "repo1-s3-verify-tls=${verify_tls_val}" >> "$config_file"
        fi
        [ -n "${PGBACKREST_REPO_S3_URI_STYLE:-${PGBACKREST_REPO1_S3_URI_STYLE:-}}" ] && echo "repo1-s3-uri-style=${PGBACKREST_REPO_S3_URI_STYLE:-${PGBACKREST_REPO1_S3_URI_STYLE}}" >> "$config_file"
        [ -n "${PGBACKREST_REPO_S3_PORT:-${PGBACKREST_REPO1_S3_PORT:-}}" ] && echo "repo1-s3-port=${PGBACKREST_REPO_S3_PORT:-${PGBACKREST_REPO1_S3_PORT}}" >> "$config_file"
        [ -n "${PGBACKREST_REPO_S3_STORAGE_CLASS:-${PGBACKREST_REPO1_S3_STORAGE_CLASS:-}}" ] && echo "repo1-s3-storage-class=${PGBACKREST_REPO_S3_STORAGE_CLASS:-${PGBACKREST_REPO1_S3_STORAGE_CLASS}}" >> "$config_file"
        [ -n "${PGBACKREST_REPO_S3_TOKEN:-${PGBACKREST_REPO1_S3_TOKEN:-}}" ] && echo "repo1-s3-token=${PGBACKREST_REPO_S3_TOKEN:-${PGBACKREST_REPO1_S3_TOKEN}}" >> "$config_file"
        [ -n "${PGBACKREST_REPO_S3_CA_FILE:-${PGBACKREST_REPO1_S3_CA_FILE:-}}" ] && echo "repo1-s3-ca-file=${PGBACKREST_REPO_S3_CA_FILE:-${PGBACKREST_REPO1_S3_CA_FILE}}" >> "$config_file"
        [ -n "${PGBACKREST_REPO_S3_CA_PATH:-${PGBACKREST_REPO1_S3_CA_PATH:-}}" ] && echo "repo1-s3-ca-path=${PGBACKREST_REPO_S3_CA_PATH:-${PGBACKREST_REPO1_S3_CA_PATH}}" >> "$config_file"
        # Set the S3 repository path (prefer override if provided)
        if [ -n "$repo1_path_override" ]; then
            echo "repo1-path=${repo1_path_override}" >> "$config_file"
        else
            echo "repo1-path=/pgbackrest" >> "$config_file"
        fi
    elif [ "$repo1_type" = "gcs" ]; then
        # GCS-specific configuration
        [ -n "${PGBACKREST_REPO_GCS_BUCKET:-${PGBACKREST_REPO1_GCS_BUCKET:-}}" ] && echo "repo1-gcs-bucket=${PGBACKREST_REPO_GCS_BUCKET:-${PGBACKREST_REPO1_GCS_BUCKET}}" >> "$config_file"
        [ -n "${PGBACKREST_REPO_GCS_ENDPOINT:-${PGBACKREST_REPO1_GCS_ENDPOINT:-}}" ] && echo "repo1-gcs-endpoint=${PGBACKREST_REPO_GCS_ENDPOINT:-${PGBACKREST_REPO1_GCS_ENDPOINT}}" >> "$config_file"
        [ -n "${PGBACKREST_REPO_GCS_KEY:-${PGBACKREST_REPO1_GCS_KEY:-}}" ] && echo "repo1-gcs-key=${PGBACKREST_REPO_GCS_KEY:-${PGBACKREST_REPO1_GCS_KEY}}" >> "$config_file"
        [ -n "${PGBACKREST_REPO_GCS_KEY_TYPE:-${PGBACKREST_REPO1_GCS_KEY_TYPE:-}}" ] && echo "repo1-gcs-key-type=${PGBACKREST_REPO_GCS_KEY_TYPE:-${PGBACKREST_REPO1_GCS_KEY_TYPE}}" >> "$config_file"
        [ -n "${PGBACKREST_REPO_GCS_USER_PROJECT:-${PGBACKREST_REPO1_GCS_USER_PROJECT:-}}" ] && echo "repo1-gcs-user-project=${PGBACKREST_REPO_GCS_USER_PROJECT:-${PGBACKREST_REPO1_GCS_USER_PROJECT}}" >> "$config_file"
        # Set the GCS repository path (prefer override if provided)
        if [ -n "$repo1_path_override" ]; then
            echo "repo1-path=${repo1_path_override}" >> "$config_file"
        else
            echo "repo1-path=/pgbackrest" >> "$config_file"
        fi
    elif [ "$repo1_type" = "sftp" ]; then
        # SFTP-specific configuration
        local sftp_host="${PGBACKREST_REPO_SFTP_HOST:-${PGBACKREST_REPO1_SFTP_HOST:-}}"
        [ -n "$sftp_host" ] && echo "repo1-sftp-host=$sftp_host" >> "$config_file"
        [ -n "${PGBACKREST_REPO_SFTP_HOST_PORT:-${PGBACKREST_REPO1_SFTP_HOST_PORT:-}}" ] && echo "repo1-sftp-host-port=${PGBACKREST_REPO_SFTP_HOST_PORT:-${PGBACKREST_REPO1_SFTP_HOST_PORT}}" >> "$config_file"
        [ -n "${PGBACKREST_REPO_SFTP_HOST_USER:-${PGBACKREST_REPO1_SFTP_HOST_USER:-}}" ] && echo "repo1-sftp-host-user=${PGBACKREST_REPO_SFTP_HOST_USER:-${PGBACKREST_REPO1_SFTP_HOST_USER}}" >> "$config_file"
        [ -n "${PGBACKREST_REPO_SFTP_HOST_FINGERPRINT:-${PGBACKREST_REPO1_SFTP_HOST_FINGERPRINT:-}}" ] && echo "repo1-sftp-host-fingerprint=${PGBACKREST_REPO_SFTP_HOST_FINGERPRINT:-${PGBACKREST_REPO1_SFTP_HOST_FINGERPRINT}}" >> "$config_file"
        [ -n "${PGBACKREST_REPO_SFTP_HOST_KEY_CHECK_TYPE:-${PGBACKREST_REPO1_SFTP_HOST_KEY_CHECK_TYPE:-}}" ] && echo "repo1-sftp-host-key-check-type=${PGBACKREST_REPO_SFTP_HOST_KEY_CHECK_TYPE:-${PGBACKREST_REPO1_SFTP_HOST_KEY_CHECK_TYPE}}" >> "$config_file"
        [ -n "${PGBACKREST_REPO_SFTP_HOST_KEY_HASH_TYPE:-${PGBACKREST_REPO1_SFTP_HOST_KEY_HASH_TYPE:-}}" ] && echo "repo1-sftp-host-key-hash-type=${PGBACKREST_REPO_SFTP_HOST_KEY_HASH_TYPE:-${PGBACKREST_REPO1_SFTP_HOST_KEY_HASH_TYPE}}" >> "$config_file"
        [ -n "${PGBACKREST_REPO_SFTP_PRIVATE_KEY_FILE:-${PGBACKREST_REPO1_SFTP_PRIVATE_KEY_FILE:-}}" ] && echo "repo1-sftp-private-key-file=${PGBACKREST_REPO_SFTP_PRIVATE_KEY_FILE:-${PGBACKREST_REPO1_SFTP_PRIVATE_KEY_FILE}}" >> "$config_file"
        [ -n "${PGBACKREST_REPO_SFTP_PRIVATE_KEY_PASSPHRASE:-${PGBACKREST_REPO1_SFTP_PRIVATE_KEY_PASSPHRASE:-}}" ] && echo "repo1-sftp-private-key-passphrase=${PGBACKREST_REPO_SFTP_PRIVATE_KEY_PASSPHRASE:-${PGBACKREST_REPO1_SFTP_PRIVATE_KEY_PASSPHRASE}}" >> "$config_file"
        [ -n "${PGBACKREST_REPO_SFTP_PUBLIC_KEY_FILE:-${PGBACKREST_REPO1_SFTP_PUBLIC_KEY_FILE:-}}" ] && echo "repo1-sftp-public-key-file=${PGBACKREST_REPO_SFTP_PUBLIC_KEY_FILE:-${PGBACKREST_REPO1_SFTP_PUBLIC_KEY_FILE}}" >> "$config_file"
        if [ -n "${PGBACKREST_REPO_SFTP_KNOWN_HOSTS:-${PGBACKREST_REPO1_SFTP_KNOWN_HOSTS:-}}" ]; then
            local known_hosts_combined="${PGBACKREST_REPO_SFTP_KNOWN_HOSTS:-${PGBACKREST_REPO1_SFTP_KNOWN_HOSTS}}"
            # Split on comma or space
            IFS=', ' read -r -a _kh_array <<< "$known_hosts_combined"
            for _kh in "${_kh_array[@]}"; do
                [ -n "$_kh" ] && echo "repo1-sftp-known-host=$_kh" >> "$config_file"
            done
        fi
        # Set the remote path for SFTP repository (prefer override if provided)
        if [ -n "$repo1_path_override" ]; then
            echo "repo1-path=${repo1_path_override}" >> "$config_file"
        else
            echo "repo1-path=/home/$PGBACKREST_REPO_SFTP_HOST_USER/pgbackrest" >> "$config_file"
        fi
    elif [ "$repo1_type" = "azure" ]; then
        # Azure-specific configuration
        [ -n "${PGBACKREST_REPO_AZURE_ACCOUNT:-${PGBACKREST_REPO1_AZURE_ACCOUNT:-}}" ] && echo "repo1-azure-account=${PGBACKREST_REPO_AZURE_ACCOUNT:-${PGBACKREST_REPO1_AZURE_ACCOUNT}}" >> "$config_file"
        [ -n "${PGBACKREST_REPO_AZURE_CONTAINER:-${PGBACKREST_REPO1_AZURE_CONTAINER:-}}" ] && echo "repo1-azure-container=${PGBACKREST_REPO_AZURE_CONTAINER:-${PGBACKREST_REPO1_AZURE_CONTAINER}}" >> "$config_file"
        [ -n "${PGBACKREST_REPO_AZURE_ENDPOINT:-${PGBACKREST_REPO1_AZURE_ENDPOINT:-}}" ] && echo "repo1-azure-endpoint=${PGBACKREST_REPO_AZURE_ENDPOINT:-${PGBACKREST_REPO1_AZURE_ENDPOINT}}" >> "$config_file"
        [ -n "${PGBACKREST_REPO_AZURE_KEY:-${PGBACKREST_REPO1_AZURE_KEY:-}}" ] && echo "repo1-azure-key=${PGBACKREST_REPO_AZURE_KEY:-${PGBACKREST_REPO1_AZURE_KEY}}" >> "$config_file"
        [ -n "${PGBACKREST_REPO_AZURE_KEY_TYPE:-${PGBACKREST_REPO1_AZURE_KEY_TYPE:-}}" ] && echo "repo1-azure-key-type=${PGBACKREST_REPO_AZURE_KEY_TYPE:-${PGBACKREST_REPO1_AZURE_KEY_TYPE}}" >> "$config_file"
        [ -n "${PGBACKREST_REPO_AZURE_URI_STYLE:-${PGBACKREST_REPO1_AZURE_URI_STYLE:-}}" ] && echo "repo1-azure-uri-style=${PGBACKREST_REPO_AZURE_URI_STYLE:-${PGBACKREST_REPO1_AZURE_URI_STYLE}}" >> "$config_file"
        # Set the Azure repository path (prefer override if provided)
        if [ -n "$repo1_path_override" ]; then
            echo "repo1-path=${repo1_path_override}" >> "$config_file"
        else
            echo "repo1-path=/pgbackrest" >> "$config_file"
        fi
    else
        log_warn "Unknown PGBACKREST_REPO_TYPE='${repo1_type}', defaulting to posix behavior"
        if [ -n "$repo1_path_override" ]; then
            echo "repo1-path=${repo1_path_override}" >> "$config_file"
        else
            echo "repo1-path=${backup_dir}" >> "$config_file"
        fi
    fi

    # Add stanza configuration section
    cat >> "$config_file" << EOF

[${PGBACKREST_STANZA:-default}]
pg1-path=${data_dir}
pg1-port=${POSTGRESQL_PORT:-5432}
pg1-user=${POSTGRES_USER:-postgres}
EOF

    # Add password if provided
    if [ -n "${PGBACKREST_PASSWORD:-}" ]; then
        echo "pg1-password=${PGBACKREST_PASSWORD}" >> "$config_file"
    fi

    # Set secure permissions
    set_secure_permissions "$config_file"

    log_info "Created pgBackRest configuration: $config_file"

    # Ensure the main backup directory exists and has correct permissions
    mkdir -p "$backup_dir"
    chmod 750 "$backup_dir"
    if id "$POSTGRES_USER" >/dev/null 2>&1; then
        chown "$POSTGRES_USER:$POSTGRES_GROUP" "$backup_dir"
        log_debug "Set main backup directory permissions 750 and ownership to $POSTGRES_USER:$POSTGRES_GROUP"
    fi

    # Create local support directories (always needed for logs/locks/spool)
    local spool_subdir="${backup_dir}/spool"
    local log_subdir="${backup_dir}/log"
    local lock_subdir="${backup_dir}/lock"
    mkdir -p "$spool_subdir" "$log_subdir" "$lock_subdir"
    
    # Set pgBackRest-specific permissions (need write access for postgres user)
    chmod 750 "$spool_subdir" "$log_subdir" "$lock_subdir"
    if id "$POSTGRES_USER" >/dev/null 2>&1; then
        chown "$POSTGRES_USER:$POSTGRES_GROUP" "$spool_subdir" "$log_subdir" "$lock_subdir"
        log_debug "Set pgBackRest directory permissions 750 and ownership to $POSTGRES_USER:$POSTGRES_GROUP"
    else
        log_warn "PostgreSQL user $POSTGRES_USER does not exist, using current user ownership"
    fi

    # Only create local repository data directories if using a posix/filesystem repository
    if [ "$repo1_type" = "posix" ] || [ "$repo1_type" = "filesystem" ]; then
        local backup_subdir="$backup_dir/backup/${PGBACKREST_STANZA:-default}"
        local archive_subdir="$backup_dir/archive/${PGBACKREST_STANZA:-default}"
        mkdir -p "$backup_subdir" "$archive_subdir"
        
        # Set pgBackRest-specific permissions for backup directories
        chmod 750 "$backup_subdir" "$archive_subdir"
        if id "$POSTGRES_USER" >/dev/null 2>&1; then
            chown "$POSTGRES_USER:$POSTGRES_GROUP" "$backup_subdir" "$archive_subdir"
            log_debug "Set pgBackRest backup directory permissions 750 and ownership to $POSTGRES_USER:$POSTGRES_GROUP"
        else
            log_warn "PostgreSQL user $POSTGRES_USER does not exist, using current user ownership"
        fi
        log_debug "Created pgBackRest posix repository directories: backup, archive"
    else
        log_debug "Skipping creation of local backup/archive directories for repo1-type=${repo1_type}"
    fi
}

# Enable WAL archiving in postgresql.conf
enable_archiving() {
    local data_dir="${PGDATA:-/usr/local/pgsql/data}"
    local config_file="$data_dir/postgresql.conf"

    log_info "Enabling WAL archiving in postgresql.conf"

    # Check if config file exists
    if [ ! -f "$config_file" ]; then
        log_error "postgresql.conf not found: $config_file"
        return 1
    fi

    if [ "${PGBACKREST_ARCHIVE_ENABLE:-true}" != "true" ]; then
        log_info "PGBACKREST_ARCHIVE_ENABLE=false; skipping archive configuration"
    else
        if [ "${PATRONI_ENABLE:-false}" = "true" ]; then
            log_info "Patroni enabled; archive configuration will be managed via patroni.yml"
        else
            apply_postgres_setting "archive_mode" "on"
            local clean_env_cmd
            clean_env_cmd="$(generate_clean_env_command)"
            local archive_cmd="$clean_env_cmd pgbackrest --config=/etc/pgbackrest.conf --stanza=${PGBACKREST_STANZA:-default} archive-push %p"
            if [ -n "${PGBACKREST_ARCHIVE_COMMAND_EXTRA:-}" ]; then
                archive_cmd="${archive_cmd} ${PGBACKREST_ARCHIVE_COMMAND_EXTRA}"
            fi
            apply_postgres_setting "archive_command" "$archive_cmd"
            apply_postgres_setting "archive_timeout" "${ARCHIVE_TIMEOUT:-1800s}"
        fi
    fi

    if [ "${PATRONI_ENABLE:-false}" != "true" ]; then
        # Set WAL parameters for replication when managing postgresql.conf directly
        apply_postgres_setting "wal_level" "replica"
        apply_postgres_setting "max_wal_senders" "${PATRONI_MAX_WAL_SENDERS:-10}"
        apply_postgres_setting "max_replication_slots" "${PATRONI_MAX_REPLICATION_SLOTS:-10}"
    else
        log_debug "Skipping direct WAL tuning because Patroni manages postgresql.conf"
    fi

    log_info "WAL archiving configuration processed"
}

# Create pgBackRest stanza (available for export to runtime scripts)
create_pgbackrest_stanza() {
    local stanza="${PGBACKREST_STANZA:-default}"
    
    log_info "Creating pgBackRest stanza: $stanza"
    
    # Check if PostgreSQL is running by attempting to connect
    local max_attempts=30
    local attempt=1
    local pg_ready=false
    
    log_debug "Waiting for PostgreSQL to be ready for stanza creation..."
    
    while [ $attempt -le $max_attempts ]; do
        if pg_isready -q -h localhost -p "${POSTGRESQL_PORT:-5432}" -U "${POSTGRES_USER:-postgres}"; then
            pg_ready=true
            break
        fi
        log_debug "Attempt $attempt/$max_attempts: PostgreSQL not ready, waiting..."
        sleep 2
        ((attempt++))
    done
    
    if [ "$pg_ready" = false ]; then
        log_error "PostgreSQL is not ready after $max_attempts attempts. Cannot create stanza."
        return 1
    fi
    
    log_debug "PostgreSQL is ready, proceeding with stanza creation"
    
    # Try to create the stanza first
    if run_pgbackrest --config=/etc/pgbackrest.conf --stanza="$stanza" stanza-create; then
        log_info "Successfully created pgBackRest stanza: $stanza"
    else
        local exit_code=$?
        log_warn "Initial stanza-create failed (exit code: $exit_code), checking if stanza upgrade is needed"
        
        # Error code 28 typically indicates backup/archive info files exist but don't match
        # Try stanza-upgrade to handle existing backup files
        log_info "Attempting stanza upgrade to handle existing backup files"
        if run_pgbackrest --config=/etc/pgbackrest.conf --stanza="$stanza" stanza-upgrade; then
            log_info "Successfully upgraded pgBackRest stanza: $stanza"
        else
            log_error "Both stanza-create and stanza-upgrade failed for stanza: $stanza"
            log_info "This may indicate:"
            log_info "  1. S3 connectivity issues"
            log_info "  2. Permission problems with S3 bucket"
            log_info "  3. Incompatible backup files in repository"
            log_info "  4. Database system identifier mismatch"
            log_info "To resolve manually:"
            log_info "  - Check S3 credentials and connectivity"
            log_info "  - Clear the S3 bucket if safe to do so"
            log_info "  - Run 'pgbackrest --stanza=$stanza info' for diagnostics"
            return 1
        fi
    fi
    
    # Verify stanza was created successfully
    if run_pgbackrest --config=/etc/pgbackrest.conf --stanza="$stanza" check; then
        log_info "pgBackRest stanza verification successful: $stanza"
    else
        log_warn "pgBackRest stanza verification failed, but stanza was created"
    fi
}

# Apply a PostgreSQL setting (local function for this script)
apply_postgres_setting() {
    local setting="$1"
    local value="$2"

    if [ -z "$value" ]; then
        return 0
    fi

    local data_dir="${PGDATA:-/usr/local/pgsql/data}"
    local config_file="$data_dir/postgresql.conf"

    log_debug "Applying PostgreSQL setting: $setting = $value"

    # Determine formatting based on value type
    local formatted_value
    if [[ "$value" =~ ^[0-9]+$ ]]; then
        # Pure numbers - unquoted
        formatted_value="$value"
    elif [[ "$value" =~ ^(on|off|true|false|replica|minimal|archive|hot_standby)$ ]]; then
        # Known PostgreSQL keywords - unquoted
        formatted_value="$value"
    else
        # Everything else (strings, time values, etc.) - quoted
        formatted_value="'$value'"
    fi

    # Check if setting already exists
    if grep -q "^[[:space:]]*${setting}[[:space:]]*=" "$config_file"; then
        # Replace existing setting
        sed -i "s|^[[:space:]]*${setting}[[:space:]]*=.*|${setting} = ${formatted_value}|" "$config_file"
    else
        # Add new setting
        echo "${setting} = ${formatted_value}" >> "$config_file"
    fi
}

# Test backup connectivity
test_backup_connectivity() {
    log_info "Testing backup system connectivity"

    # Test pgBackRest version
    if ! run_pgbackrest version; then
        log_error "pgBackRest is not working properly"
        return 1
    fi

    log_debug "pgBackRest version check passed"

    # Test stanza creation (this will fail if PostgreSQL is not running)
    local stanza="${PGBACKREST_STANZA:-default}"

    log_debug "Testing stanza creation: $stanza"

    # Note: This test requires PostgreSQL to be running
    # We'll do a basic configuration validation instead
    if [ ! -f "/etc/pgbackrest.conf" ]; then
        log_error "pgBackRest configuration file not found"
        return 1
    fi

    # Basic configuration file syntax check (don't try to connect to PostgreSQL)
    log_debug "Validating pgBackRest configuration file syntax"
    
    # Just check if the config file has the basic required sections
    if grep -q "^\[global\]" "/etc/pgbackrest.conf" && grep -q "^\[${stanza}\]" "/etc/pgbackrest.conf"; then
        log_info "pgBackRest configuration file has required sections"
    else
        log_error "pgBackRest configuration file is missing required sections"
        return 1
    fi

    # Test local paths only for posix/filesystem repo
    local repo1_type="${PGBACKREST_REPO_TYPE:-posix}"
    if [ "$repo1_type" = "posix" ] || [ "$repo1_type" = "filesystem" ]; then
        local backup_dir="${PGBACKUP:-/usr/local/pgsql/backup}"
        if [ ! -w "$backup_dir" ]; then
            log_error "Backup directory is not writable: $backup_dir"
            return 1
        fi
    else
        log_debug "Skipping local backup directory permission check for repo1-type=${repo1_type}"
    fi

    log_info "Backup system connectivity test completed"
}

# Export functions for use by other scripts
export -f run_pgbackrest
export -f create_pgbackrest_stanza

# Execute main function
main "$@"