#!/bin/bash
# 04-backup.sh - pgBackRest and WAL archiving setup
# Configures backup system and WAL archiving

# Set strict error handling
set -euo pipefail

# Source utility functions
source /opt/container/entrypoint.d/scripts/utils/logging.sh
source /opt/container/entrypoint.d/scripts/utils/validation.sh
source /opt/container/entrypoint.d/scripts/utils/security.sh

# Helper function to run pgBackRest commands without problematic environment variables
run_pgbackrest() {
    env -u PGBACKREST_ENABLE pgbackrest "$@"
}

# Main function
main() {
    log_script_start "04-backup.sh"

    # Only proceed if backup is enabled
    if [ "${PGBACKREST_ENABLE:-false}" != "true" ]; then
        log_info "Backup not enabled, skipping backup setup"
        return 0
    fi

    # Validate environment before proceeding
    if ! validate_environment; then
        log_error "Environment validation failed"
        return 1
    fi

    # Configure pgBackRest
    configure_pgbackrest

    # Enable archiving in postgresql.conf
    enable_archiving

    # Note: Stanza creation is handled in the runtime phase when PostgreSQL is running
    # See startup.sh for stanza creation logic

    # Test backup connectivity (basic checks only)
    test_backup_connectivity

    log_script_end "04-backup.sh"
}

# Configure pgBackRest
configure_pgbackrest() {
    log_info "Configuring pgBackRest"

    local backup_dir="${PGBACKUP:-/usr/local/pgsql/backup}"
    local data_dir="${PGDATA:-/usr/local/pgsql/data}"
    local config_file="/etc/pgbackrest.conf"

    # Create pgBackRest configuration
    cat > "$config_file" << EOF
# pgBackRest configuration generated by container
[global]
repo1-path=${backup_dir}
repo1-retention-full=2
repo1-retention-diff=6
log-level-console=info
log-level-file=debug
log-path=${backup_dir}/log
lock-path=${backup_dir}/lock

[${PGBACKREST_STANZA:-default}]
pg1-path=${data_dir}
pg1-port=${POSTGRESQL_PORT:-5432}
pg1-user=${POSTGRES_USER:-postgres}
EOF

    # Add password if provided
    if [ -n "${PGBACKREST_PASSWORD:-}" ]; then
        echo "pg1-password=${PGBACKREST_PASSWORD}" >> "$config_file"
    fi

    # Set secure permissions
    set_secure_permissions "$config_file"

    log_info "Created pgBackRest configuration: $config_file"

    # Create pgBackRest repository directory structure
    local backup_subdir="$backup_dir/backup/${PGBACKREST_STANZA:-default}"
    local archive_subdir="$backup_dir/archive/${PGBACKREST_STANZA:-default}"
    local spool_subdir="$backup_dir/spool"
    local log_subdir="$backup_dir/log"
    local lock_subdir="$backup_dir/lock"

    mkdir -p "$backup_subdir" "$archive_subdir" "$spool_subdir" "$log_subdir" "$lock_subdir"
    set_secure_permissions "$backup_subdir"
    set_secure_permissions "$archive_subdir"
    set_secure_permissions "$spool_subdir"
    set_secure_permissions "$log_subdir"
    set_secure_permissions "$lock_subdir"

    log_debug "Created pgBackRest repository directories: backup, archive, spool, log, lock"
}

# Enable WAL archiving in postgresql.conf
enable_archiving() {
    local data_dir="${PGDATA:-/usr/local/pgsql/data}"
    local config_file="$data_dir/postgresql.conf"

    log_info "Enabling WAL archiving in postgresql.conf"

    # Check if config file exists
    if [ ! -f "$config_file" ]; then
        log_error "postgresql.conf not found: $config_file"
        return 1
    fi

    # Set archive parameters
    # apply_postgres_setting "archive_mode" "on"
    # apply_postgres_setting "archive_command" "pgbackrest --config=/etc/pgbackrest.conf --stanza=${PGBACKREST_STANZA:-default} archive-push ${PGDATA}/%p"
    apply_postgres_setting "archive_timeout" "${ARCHIVE_TIMEOUT:-1800s}"

    # Set WAL parameters for replication
    apply_postgres_setting "wal_level" "replica"
    apply_postgres_setting "max_wal_senders" "${PATRONI_MAX_WAL_SENDERS:-10}"
    apply_postgres_setting "max_replication_slots" "${PATRONI_MAX_REPLICATION_SLOTS:-10}"

    log_info "WAL archiving enabled in postgresql.conf"
}

# Create pgBackRest stanza (available for export to runtime scripts)
create_pgbackrest_stanza() {
    local stanza="${PGBACKREST_STANZA:-default}"
    
    log_info "Creating pgBackRest stanza: $stanza"
    
    # Check if PostgreSQL is running by attempting to connect
    local max_attempts=30
    local attempt=1
    local pg_ready=false
    
    log_debug "Waiting for PostgreSQL to be ready for stanza creation..."
    
    while [ $attempt -le $max_attempts ]; do
        if pg_isready -q -h localhost -p "${POSTGRESQL_PORT:-5432}" -U "${POSTGRES_USER:-postgres}"; then
            pg_ready=true
            break
        fi
        log_debug "Attempt $attempt/$max_attempts: PostgreSQL not ready, waiting..."
        sleep 2
        ((attempt++))
    done
    
    if [ "$pg_ready" = false ]; then
        log_error "PostgreSQL is not ready after $max_attempts attempts. Cannot create stanza."
        return 1
    fi
    
    log_debug "PostgreSQL is ready, proceeding with stanza creation"
    
    # Create the stanza
    if run_pgbackrest --config=/etc/pgbackrest.conf --stanza="$stanza" stanza-create; then
        log_info "Successfully created pgBackRest stanza: $stanza"
    else
        log_error "Failed to create pgBackRest stanza: $stanza"
        return 1
    fi
    
    # Verify stanza was created successfully
    if run_pgbackrest --config=/etc/pgbackrest.conf --stanza="$stanza" check; then
        log_info "pgBackRest stanza verification successful: $stanza"
    else
        log_warn "pgBackRest stanza verification failed, but stanza was created"
    fi
}

# Apply a PostgreSQL setting (local function for this script)
apply_postgres_setting() {
    local setting="$1"
    local value="$2"

    if [ -z "$value" ]; then
        return 0
    fi

    local data_dir="${PGDATA:-/usr/local/pgsql/data}"
    local config_file="$data_dir/postgresql.conf"

    log_debug "Applying PostgreSQL setting: $setting = $value"

    # Determine formatting based on value type
    local formatted_value
    if [[ "$value" =~ ^[0-9]+$ ]]; then
        # Pure numbers - unquoted
        formatted_value="$value"
    elif [[ "$value" =~ ^(on|off|true|false|replica|minimal|archive|hot_standby)$ ]]; then
        # Known PostgreSQL keywords - unquoted
        formatted_value="$value"
    else
        # Everything else (strings, time values, etc.) - quoted
        formatted_value="'$value'"
    fi

    # Check if setting already exists
    if grep -q "^[[:space:]]*${setting}[[:space:]]*=" "$config_file"; then
        # Replace existing setting
        sed -i "s|^[[:space:]]*${setting}[[:space:]]*=.*|${setting} = ${formatted_value}|" "$config_file"
    else
        # Add new setting
        echo "${setting} = ${formatted_value}" >> "$config_file"
    fi
}

# Test backup connectivity
test_backup_connectivity() {
    log_info "Testing backup system connectivity"

    # Test pgBackRest version
    if ! run_pgbackrest version; then
        log_error "pgBackRest is not working properly"
        return 1
    fi

    log_debug "pgBackRest version check passed"

    # Test stanza creation (this will fail if PostgreSQL is not running)
    local stanza="${PGBACKREST_STANZA:-default}"

    log_debug "Testing stanza creation: $stanza"

    # Note: This test requires PostgreSQL to be running
    # We'll do a basic configuration validation instead
    if [ ! -f "/etc/pgbackrest.conf" ]; then
        log_error "pgBackRest configuration file not found"
        return 1
    fi

    # Basic configuration file syntax check (don't try to connect to PostgreSQL)
    log_debug "Validating pgBackRest configuration file syntax"
    
    # Just check if the config file has the basic required sections
    if grep -q "^\[global\]" "/etc/pgbackrest.conf" && grep -q "^\[${stanza}\]" "/etc/pgbackrest.conf"; then
        log_info "pgBackRest configuration file has required sections"
    else
        log_error "pgBackRest configuration file is missing required sections"
        return 1
    fi

    # Test backup directory permissions
    local backup_dir="${PGBACKUP:-/usr/local/pgsql/backup}"
    if [ ! -w "$backup_dir" ]; then
        log_error "Backup directory is not writable: $backup_dir"
        return 1
    fi

    log_info "Backup system connectivity test completed"
}

# Export functions for use by other scripts
export -f run_pgbackrest
export -f create_pgbackrest_stanza

# Execute main function
main "$@"