#!/bin/bash
# 04-backup.sh - pgBackRest and WAL archiving setup
# Configures backup system and WAL archiving

# Set strict error handling
set -euo pipefail

# Source utility functions
source /opt/container/entrypoint.d/scripts/utils/logging.sh
source /opt/container/entrypoint.d/scripts/utils/validation.sh
source /opt/container/entrypoint.d/scripts/utils/security.sh

# Helper function to run pgBackRest commands without problematic environment variables
run_pgbackrest() {
    env -u PGBACKREST_ENABLE pgbackrest "$@"
}

# Main function
main() {
    log_script_start "04-backup.sh"

    # Only proceed if backup is enabled
    if [ "${PGBACKREST_ENABLE:-false}" != "true" ]; then
        log_info "Backup not enabled, skipping backup setup"
        return 0
    fi

    # Validate environment before proceeding
    if ! validate_environment; then
        log_error "Environment validation failed"
        return 1
    fi

    # Configure pgBackRest
    configure_pgbackrest

    # Enable archiving in postgresql.conf
    enable_archiving

    # Note: Stanza creation is handled in the runtime phase when PostgreSQL is running
    # See startup.sh for stanza creation logic

    # Test backup connectivity (basic checks only)
    test_backup_connectivity

    log_script_end "04-backup.sh"
}

# Configure pgBackRest
configure_pgbackrest() {
    log_info "Configuring pgBackRest"

    local backup_dir="${PGBACKUP:-/usr/local/pgsql/backup}"
    local data_dir="${PGDATA:-/usr/local/pgsql/data}"
    local config_file="/etc/pgbackrest.conf"
    local repo1_type="${PGBACKREST_REPO1_TYPE:-posix}"
    local repo1_path_override="${PGBACKREST_REPO1_PATH:-}" # Optional explicit override

    # Create pgBackRest configuration
    cat > "$config_file" << EOF
# pgBackRest configuration generated by container
[global]
repo1-retention-full=${PGBACKREST_REPO1_RETENTION_FULL:-2}
repo1-retention-diff=${PGBACKREST_REPO1_RETENTION_DIFF:-6}
log-level-console=info
log-level-file=debug
log-path=${backup_dir}/log
lock-path=${backup_dir}/lock
spool-path=${backup_dir}/spool

# Repository 1 configuration
repo1-type=${repo1_type}
EOF

    # If posix (filesystem) repository, set path (prefer override if provided)
    if [ "${repo1_type}" = "posix" ] || [ "${repo1_type}" = "filesystem" ]; then
        if [ -n "$repo1_path_override" ]; then
            echo "repo1-path=${repo1_path_override}" >> "$config_file"
        else
            echo "repo1-path=${backup_dir}" >> "$config_file"
        fi
    elif [ "$repo1_type" = "s3" ]; then
        # Map S3-specific environment variables to pgBackRest configuration if provided
        # Required: bucket & endpoint (validated elsewhere)
        [ -n "${PGBACKREST_REPO1_S3_BUCKET:-}" ] && echo "repo1-s3-bucket=${PGBACKREST_REPO1_S3_BUCKET}" >> "$config_file"
        [ -n "${PGBACKREST_REPO1_S3_ENDPOINT:-}" ] && echo "repo1-s3-endpoint=${PGBACKREST_REPO1_S3_ENDPOINT}" >> "$config_file"
        [ -n "${PGBACKREST_REPO1_S3_REGION:-}" ] && echo "repo1-s3-region=${PGBACKREST_REPO1_S3_REGION}" >> "$config_file"
        [ -n "${PGBACKREST_REPO1_S3_KEY:-}" ] && echo "repo1-s3-key=${PGBACKREST_REPO1_S3_KEY}" >> "$config_file"
        [ -n "${PGBACKREST_REPO1_S3_KEY_SECRET:-}" ] && echo "repo1-s3-key-secret=${PGBACKREST_REPO1_S3_KEY_SECRET}" >> "$config_file"
        if [ -n "${PGBACKREST_REPO1_S3_VERIFY_TLS:-}" ]; then
            local verify_tls_val
            case "${PGBACKREST_REPO1_S3_VERIFY_TLS}" in
                true|TRUE|1|y|Y) verify_tls_val="y" ;;
                false|FALSE|0|n|N) verify_tls_val="n" ;;
                *) verify_tls_val="y" ;; # default safe
            esac
            echo "repo1-s3-verify-tls=${verify_tls_val}" >> "$config_file"
        fi
        [ -n "${PGBACKREST_REPO1_S3_URI_STYLE:-}" ] && echo "repo1-s3-uri-style=${PGBACKREST_REPO1_S3_URI_STYLE}" >> "$config_file"
        [ -n "${PGBACKREST_REPO1_S3_PORT:-}" ] && echo "repo1-s3-port=${PGBACKREST_REPO1_S3_PORT}" >> "$config_file"
        [ -n "${PGBACKREST_REPO1_S3_STORAGE_CLASS:-}" ] && echo "repo1-s3-storage-class=${PGBACKREST_REPO1_S3_STORAGE_CLASS}" >> "$config_file"
        [ -n "${PGBACKREST_REPO1_S3_TOKEN:-}" ] && echo "repo1-s3-token=${PGBACKREST_REPO1_S3_TOKEN}" >> "$config_file"
        [ -n "${PGBACKREST_REPO1_S3_CA_FILE:-}" ] && echo "repo1-s3-ca-file=${PGBACKREST_REPO1_S3_CA_FILE}" >> "$config_file"
        [ -n "${PGBACKREST_REPO1_S3_CA_PATH:-}" ] && echo "repo1-s3-ca-path=${PGBACKREST_REPO1_S3_CA_PATH}" >> "$config_file"
    else
        log_warn "Unknown PGBACKREST_REPO1_TYPE='${repo1_type}', defaulting to posix behavior"
        echo "repo1-path=${backup_dir}" >> "$config_file"
    fi

[${PGBACKREST_STANZA:-default}]
pg1-path=${data_dir}
pg1-port=${POSTGRESQL_PORT:-5432}
pg1-user=${POSTGRES_USER:-postgres}
EOF

    # Add password if provided
    if [ -n "${PGBACKREST_PASSWORD:-}" ]; then
        echo "pg1-password=${PGBACKREST_PASSWORD}" >> "$config_file"
    fi

    # Set secure permissions
    set_secure_permissions "$config_file"

    log_info "Created pgBackRest configuration: $config_file"

    # Create local support directories (always needed for logs/locks/spool)
    local spool_subdir="${backup_dir}/spool"
    local log_subdir="${backup_dir}/log"
    local lock_subdir="${backup_dir}/lock"
    mkdir -p "$spool_subdir" "$log_subdir" "$lock_subdir"
    set_secure_permissions "$spool_subdir" "$log_subdir" "$lock_subdir"

    # Only create local repository data directories if using a posix/filesystem repository
    if [ "$repo1_type" = "posix" ] || [ "$repo1_type" = "filesystem" ]; then
        local backup_subdir="$backup_dir/backup/${PGBACKREST_STANZA:-default}"
        local archive_subdir="$backup_dir/archive/${PGBACKREST_STANZA:-default}"
        mkdir -p "$backup_subdir" "$archive_subdir"
        set_secure_permissions "$backup_subdir" "$archive_subdir"
        log_debug "Created pgBackRest posix repository directories: backup, archive"
    else
        log_debug "Skipping creation of local backup/archive directories for repo1-type=${repo1_type}"
    fi
}

# Enable WAL archiving in postgresql.conf
enable_archiving() {
    local data_dir="${PGDATA:-/usr/local/pgsql/data}"
    local config_file="$data_dir/postgresql.conf"

    log_info "Enabling WAL archiving in postgresql.conf"

    # Check if config file exists
    if [ ! -f "$config_file" ]; then
        log_error "postgresql.conf not found: $config_file"
        return 1
    fi

    # Set archive parameters
    # apply_postgres_setting "archive_mode" "on"
    # apply_postgres_setting "archive_command" "pgbackrest --config=/etc/pgbackrest.conf --stanza=${PGBACKREST_STANZA:-default} archive-push ${PGDATA}/%p"
    apply_postgres_setting "archive_timeout" "${ARCHIVE_TIMEOUT:-1800s}"

    # Set WAL parameters for replication
    apply_postgres_setting "wal_level" "replica"
    apply_postgres_setting "max_wal_senders" "${PATRONI_MAX_WAL_SENDERS:-10}"
    apply_postgres_setting "max_replication_slots" "${PATRONI_MAX_REPLICATION_SLOTS:-10}"

    log_info "WAL archiving enabled in postgresql.conf"
}

# Create pgBackRest stanza (available for export to runtime scripts)
create_pgbackrest_stanza() {
    local stanza="${PGBACKREST_STANZA:-default}"
    
    log_info "Creating pgBackRest stanza: $stanza"
    
    # Check if PostgreSQL is running by attempting to connect
    local max_attempts=30
    local attempt=1
    local pg_ready=false
    
    log_debug "Waiting for PostgreSQL to be ready for stanza creation..."
    
    while [ $attempt -le $max_attempts ]; do
        if pg_isready -q -h localhost -p "${POSTGRESQL_PORT:-5432}" -U "${POSTGRES_USER:-postgres}"; then
            pg_ready=true
            break
        fi
        log_debug "Attempt $attempt/$max_attempts: PostgreSQL not ready, waiting..."
        sleep 2
        ((attempt++))
    done
    
    if [ "$pg_ready" = false ]; then
        log_error "PostgreSQL is not ready after $max_attempts attempts. Cannot create stanza."
        return 1
    fi
    
    log_debug "PostgreSQL is ready, proceeding with stanza creation"
    
    # Create the stanza
    if run_pgbackrest --config=/etc/pgbackrest.conf --stanza="$stanza" stanza-create; then
        log_info "Successfully created pgBackRest stanza: $stanza"
    else
        log_error "Failed to create pgBackRest stanza: $stanza"
        return 1
    fi
    
    # Verify stanza was created successfully
    if run_pgbackrest --config=/etc/pgbackrest.conf --stanza="$stanza" check; then
        log_info "pgBackRest stanza verification successful: $stanza"
    else
        log_warn "pgBackRest stanza verification failed, but stanza was created"
    fi
}

# Apply a PostgreSQL setting (local function for this script)
apply_postgres_setting() {
    local setting="$1"
    local value="$2"

    if [ -z "$value" ]; then
        return 0
    fi

    local data_dir="${PGDATA:-/usr/local/pgsql/data}"
    local config_file="$data_dir/postgresql.conf"

    log_debug "Applying PostgreSQL setting: $setting = $value"

    # Determine formatting based on value type
    local formatted_value
    if [[ "$value" =~ ^[0-9]+$ ]]; then
        # Pure numbers - unquoted
        formatted_value="$value"
    elif [[ "$value" =~ ^(on|off|true|false|replica|minimal|archive|hot_standby)$ ]]; then
        # Known PostgreSQL keywords - unquoted
        formatted_value="$value"
    else
        # Everything else (strings, time values, etc.) - quoted
        formatted_value="'$value'"
    fi

    # Check if setting already exists
    if grep -q "^[[:space:]]*${setting}[[:space:]]*=" "$config_file"; then
        # Replace existing setting
        sed -i "s|^[[:space:]]*${setting}[[:space:]]*=.*|${setting} = ${formatted_value}|" "$config_file"
    else
        # Add new setting
        echo "${setting} = ${formatted_value}" >> "$config_file"
    fi
}

# Test backup connectivity
test_backup_connectivity() {
    log_info "Testing backup system connectivity"

    # Test pgBackRest version
    if ! run_pgbackrest version; then
        log_error "pgBackRest is not working properly"
        return 1
    fi

    log_debug "pgBackRest version check passed"

    # Test stanza creation (this will fail if PostgreSQL is not running)
    local stanza="${PGBACKREST_STANZA:-default}"

    log_debug "Testing stanza creation: $stanza"

    # Note: This test requires PostgreSQL to be running
    # We'll do a basic configuration validation instead
    if [ ! -f "/etc/pgbackrest.conf" ]; then
        log_error "pgBackRest configuration file not found"
        return 1
    fi

    # Basic configuration file syntax check (don't try to connect to PostgreSQL)
    log_debug "Validating pgBackRest configuration file syntax"
    
    # Just check if the config file has the basic required sections
    if grep -q "^\[global\]" "/etc/pgbackrest.conf" && grep -q "^\[${stanza}\]" "/etc/pgbackrest.conf"; then
        log_info "pgBackRest configuration file has required sections"
    else
        log_error "pgBackRest configuration file is missing required sections"
        return 1
    fi

    # Test local paths only for posix/filesystem repo
    local repo1_type="${PGBACKREST_REPO1_TYPE:-posix}"
    if [ "$repo1_type" = "posix" ] || [ "$repo1_type" = "filesystem" ]; then
        local backup_dir="${PGBACKUP:-/usr/local/pgsql/backup}"
        if [ ! -w "$backup_dir" ]; then
            log_error "Backup directory is not writable: $backup_dir"
            return 1
        fi
    else
        log_debug "Skipping local backup directory permission check for repo1-type=${repo1_type}"
    fi

    log_info "Backup system connectivity test completed"
}

# Export functions for use by other scripts
export -f run_pgbackrest
export -f create_pgbackrest_stanza

# Execute main function
main "$@"