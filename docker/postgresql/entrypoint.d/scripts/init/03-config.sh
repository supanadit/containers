#!/bin/bash
# 03-config.sh - PostgreSQL configuration file management
# Manages postgresql.conf, pg_hba.conf, and Patroni configuration

# Set strict error handling
set -euo pipefail

# Source utility functions
source /opt/container/entrypoint.d/scripts/utils/logging.sh
source /opt/container/entrypoint.d/scripts/utils/validation.sh
source /opt/container/entrypoint.d/scripts/utils/security.sh

# Main function
main() {
    log_script_start "03-config.sh"

    # Validate environment before proceeding
    if ! validate_environment; then
        log_error "Environment validation failed"
        return 1
    fi

    # Backup original configurations
    backup_original_configs

    # Copy user-provided configurations
    copy_user_configs

    # Generate secure default configurations
    generate_secure_defaults

    # Apply environment variable overrides
    apply_environment_overrides

    # Apply external access configuration
    apply_external_access_config

    # Apply native HA configuration
    apply_native_ha_config

    # Validate final configurations
    validate_final_configs

    # Generate Patroni configuration if needed
    if [ "${USE_PATRONI:-false}" = "true" ]; then
        generate_patroni_config
    fi

    log_script_end "03-config.sh"
}

# Backup original configuration files
backup_original_configs() {
    local data_dir="${PGDATA:-/usr/local/pgsql/data}"

    log_info "Backing up original configuration files"

    local config_files=("postgresql.conf" "pg_hba.conf")

    for file in "${config_files[@]}"; do
        local source_file="$data_dir/$file"
        local backup_file="$data_dir/$file.original"

        if [ -f "$source_file" ] && [ ! -f "$backup_file" ]; then
            cp "$source_file" "$backup_file"
            # Set permissions so postgres can read the backup files
            chown postgres:postgres "$backup_file"
            chmod 644 "$backup_file"
            log_debug "Backed up $file to $file.original"
        elif [ -f "$backup_file" ]; then
            log_debug "Backup already exists for $file"
        else
            log_warn "Source file does not exist: $source_file"
        fi
    done
}

# Copy user-provided configuration files
copy_user_configs() {
    local data_dir="${PGDATA:-/usr/local/pgsql/data}"
    local config_dir="${PGCONFIG:-/usr/local/pgsql/config}"

    log_info "Copying user-provided configuration files"

    # Only proceed if config directory exists
    if [ ! -d "$config_dir" ]; then
        log_debug "Config directory does not exist, skipping user config copy"
        return 0
    fi

    local config_files=("postgresql.conf" "pg_hba.conf")

    for file in "${config_files[@]}"; do
        local source_file="$config_dir/$file"
        local dest_file="$data_dir/$file"

        if [ -f "$source_file" ]; then
            cp "$source_file" "$dest_file"
            set_secure_permissions "$dest_file"
            log_info "Copied user config: $file"
        else
            log_debug "User config not provided: $file"
        fi
    done
}

# Generate secure default configurations
generate_secure_defaults() {
    local data_dir="${PGDATA:-/usr/local/pgsql/data}"

    log_info "Generating secure default configurations"

    # Generate postgresql.conf if it doesn't exist
    if [ ! -f "$data_dir/postgresql.conf" ]; then
        generate_postgresql_conf "$data_dir/postgresql.conf"
    fi

    # Generate pg_hba.conf if it doesn't exist
    if [ ! -f "$data_dir/pg_hba.conf" ]; then
        generate_pg_hba_conf "$data_dir/pg_hba.conf"
    fi
}

# Generate secure postgresql.conf
generate_postgresql_conf() {
    local config_file="$1"

    log_debug "Generating postgresql.conf: $config_file"

    cat > "$config_file" << 'EOF'
# PostgreSQL configuration generated by container
# Basic settings
listen_addresses = '*'
port = 5432
max_connections = 100

# Memory settings
shared_buffers = 256MB
effective_cache_size = 1GB
maintenance_work_mem = 64MB
work_mem = 4MB

# WAL settings
wal_level = replica
archive_mode = off
archive_command = ''

# Logging settings
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '
log_statement = 'ddl'
log_duration = on
log_min_duration_statement = 1000

# Security settings
ssl = off
password_encryption = scram-sha-256

# Performance settings
random_page_cost = 1.1
effective_io_concurrency = 200

# Autovacuum settings
autovacuum = on
autovacuum_max_workers = 3
autovacuum_naptime = 20s

# Other settings
timezone = 'UTC'
lc_messages = 'C'
lc_monetary = 'C'
lc_numeric = 'C'
lc_time = 'C'
EOF

    set_secure_permissions "$config_file"
    log_debug "Generated secure postgresql.conf"
}

# Generate secure pg_hba.conf
generate_pg_hba_conf() {
    local config_file="$1"

    log_debug "Generating pg_hba.conf: $config_file"

    cat > "$config_file" << 'EOF'
# PostgreSQL Host Based Authentication configuration
# Generated by container

# Local connections (trust for postgres user)
local   all             postgres                                trust
local   all             all                                     md5

# Docker container connections
host    all             all             0.0.0.0/0               md5
host    all             all             ::/0                    md5

# Replication connections (if needed)
# host    replication     replicator      0.0.0.0/0               md5
EOF

    set_secure_permissions "$config_file"
    log_debug "Generated secure pg_hba.conf"
}

# Apply environment variable overrides
apply_environment_overrides() {
    local data_dir="${PGDATA:-/usr/local/pgsql/data}"

    log_info "Applying environment variable overrides"

    # PostgreSQL settings overrides
    apply_postgres_setting "shared_buffers" "${POSTGRESQL_SHARED_BUFFERS:-}"
    apply_postgres_setting "max_connections" "${POSTGRESQL_MAX_CONNECTIONS:-}"
    apply_postgres_setting "work_mem" "${POSTGRESQL_WORK_MEM:-}"
    apply_postgres_setting "maintenance_work_mem" "${POSTGRESQL_MAINTENANCE_WORK_MEM:-}"
    apply_postgres_setting "listen_addresses" "${POSTGRESQL_LISTEN_ADDRESSES:-}"
    apply_postgres_setting "log_statement" "${POSTGRESQL_LOG_STATEMENT:-}"
    apply_postgres_setting "log_duration" "${POSTGRESQL_LOG_DURATION:-}"

    # Archive settings
    if [ "${ENABLE_PGBACKREST:-false}" = "true" ]; then
        apply_postgres_setting "archive_mode" "on"
        apply_postgres_setting "archive_command" "pgbackrest --config=/etc/pgbackrest.conf --stanza=${PGBACKREST_STANZA:-default} archive-push ${PGDATA}/%p"
    else
        apply_postgres_setting "archive_mode" "off"
    fi
}

# Apply a single PostgreSQL setting
apply_postgres_setting() {
    local setting="$1"
    local value="$2"

    if [ -z "$value" ]; then
        return 0
    fi

    local data_dir="${PGDATA:-/usr/local/pgsql/data}"
    local config_file="$data_dir/postgresql.conf"

    log_debug "Applying PostgreSQL setting: $setting = $value"

    # Remove any existing occurrences (commented or uncommented)
    sed -i -E "/^[[:space:]]*#?[[:space:]]*${setting}[[:space:]]*=.*/d" "$config_file"

    # Determine formatting based on value type
    local formatted_value
    if [[ "$value" =~ ^[0-9]+$ ]]; then
        formatted_value="$value"
    elif [[ "$value" =~ ^(on|off|true|false|replica|minimal|archive|hot_standby)$ ]]; then
        formatted_value="$value"
    elif [[ "$value" =~ ^[0-9]+(kB|MB|GB|TB|ms|s|min|h|d)$ ]]; then
        formatted_value="$value"
    else
        printf -v formatted_value "'%s'" "$value"
    fi

    echo "${setting} = ${formatted_value}" >> "$config_file"
}

# Apply native HA configuration
apply_native_ha_config() {
    if [[ "${HA_MODE:-}" == "native" ]]; then
        log_info "Applying native HA configuration"
        apply_postgres_setting "listen_addresses" "*"
        apply_postgres_setting "wal_level" "replica"
        apply_postgres_setting "max_wal_senders" "10"
        apply_postgres_setting "wal_keep_size" "256MB"
        apply_postgres_setting "hot_standby" "on"

        if [[ "${REPLICATION_ROLE:-}" == "primary" ]]; then
            local hba_file="${PGDATA:-/usr/local/pgsql/data}/pg_hba.conf"
            local replication_user="${REPLICATION_USER:-replicator}"
            if ! grep -q "host replication $replication_user" "$hba_file"; then
                echo "host replication $replication_user 0.0.0.0/0 scram-sha-256" >> "$hba_file"
            fi
        fi
    fi
}

# Validate final configurations
validate_final_configs() {
    local data_dir="${PGDATA:-/usr/local/pgsql/data}"

    log_info "Validating final configurations"

    # Validate postgresql.conf
    if ! validate_postgresql_conf "$data_dir/postgresql.conf"; then
        log_error "Final postgresql.conf validation failed"
        return 1
    fi

    # Validate pg_hba.conf
    if ! validate_pg_hba_conf "$data_dir/pg_hba.conf"; then
        log_error "Final pg_hba.conf validation failed"
        return 1
    fi

    log_info "Configuration validation successful"
}

# Generate Patroni configuration
generate_patroni_config() {
    log_info "Generating Patroni configuration"

    local patroni_config="/etc/patroni.yml"
    local data_dir="${PGDATA:-/usr/local/pgsql/data}"

    # Generate basic Patroni configuration
    cat > "$patroni_config" << EOF
scope: ${PATRONI_SCOPE:-postgres-cluster}
name: ${PATRONI_NAME:-postgres-node-1}
restapi:
  listen: ${PATRONI_REST_HOST:-0.0.0.0}:${PATRONI_REST_PORT:-8008}
  connect_address: ${PATRONI_REST_HOST:-localhost}:${PATRONI_REST_PORT:-8008}
etcd:
  host: ${ETCD_HOST:-localhost}:${ETCD_PORT:-2379}
bootstrap:
  dcs:
    ttl: ${PATRONI_TTL:-30}
    loop_wait: ${PATRONI_LOOP_WAIT:-10}
    retry_timeout: ${PATRONI_RETRY_TIMEOUT:-10}
    maximum_lag_on_failover: ${PATRONI_MAX_LAG:-1048576}
    postgresql:
      use_pg_rewind: ${PATRONI_USE_PG_REWIND:-true}
      use_slots: ${PATRONI_USE_SLOTS:-true}
      parameters:
        wal_level: replica
        hot_standby: "on"
        logging_collector: "on"
        max_wal_senders: ${PATRONI_MAX_WAL_SENDERS:-10}
        max_replications_slots: ${PATRONI_MAX_REPLICATION_SLOTS:-10}
        wal_keep_segments: ${PATRONI_WAL_KEEP_SEGMENTS:-8}
        archive_mode: "${ENABLE_PGBACKREST:-off}"
        archive_timeout: ${ARCHIVE_TIMEOUT:-1800s}
        archive_command: "${ENABLE_PGBACKREST:+pgbackrest --stanza=${PGBACKREST_STANZA:-default} archive-push %p}"
postgresql:
  listen: ${POSTGRESQL_LISTEN_HOST:-0.0.0.0}:${POSTGRESQL_PORT:-5432}
  connect_address: ${POSTGRESQL_CONNECT_HOST:-localhost}:${POSTGRESQL_PORT:-5432}
  data_dir: ${data_dir}
  config_dir: ${data_dir}
  pgpass: /tmp/pgpass
  authentication:
    replication:
      username: ${PATRONI_REPLICATION_USER:-replicator}
      password: ${PATRONI_REPLICATION_PASSWORD:-replicator_password}
    superuser:
      username: ${POSTGRES_USER:-postgres}
      password: ${POSTGRES_PASSWORD:-postgres_password}
  parameters:
    unix_socket_directories: '${PGRUN:-/usr/local/pgsql/run}'
EOF

    set_secure_permissions "$patroni_config"
    log_info "Generated Patroni configuration: $patroni_config"

    # Validate the generated configuration
    if ! validate_patroni_config "$patroni_config"; then
        log_error "Generated Patroni configuration is invalid"
        return 1
    fi
}

# Apply external access configuration
apply_external_access_config() {
    log_info "Applying external access configuration"

    # Parse environment variables with defaults
    local enable_external="${EXTERNAL_ACCESS_ENABLE:-true}"
    local method="${EXTERNAL_ACCESS_METHOD:-md5}"

    # Validate authentication method
    case "$method" in
        trust|reject|md5|password|scram-sha-256) ;;
        *) 
            log_warn "Invalid EXTERNAL_ACCESS_METHOD '$method', falling back to md5"
            method="md5"
            ;;
    esac

    # Update pg_hba.conf based on configuration
    local hba_file="${PGDATA:-/usr/local/pgsql/data}/pg_hba.conf"

    if [ "$enable_external" = "true" ]; then
        # Ensure external access lines exist with correct method
        if ! grep -q "host    all             all             0.0.0.0/0" "$hba_file"; then
            echo "host    all             all             0.0.0.0/0               $method" >> "$hba_file"
        else
            sed -i "s/host    all             all             0\.0\.0\.0\/0               .*/host    all             all             0.0.0.0\/0               $method/" "$hba_file"
        fi
        if ! grep -q "host    all             all             ::/0" "$hba_file"; then
            echo "host    all             all             ::/0                    $method" >> "$hba_file"
        else
            sed -i "s/host    all             all             ::\/0                    .*/host    all             all             ::\/0                    $method/" "$hba_file"
        fi
    else
        # Remove external access lines
        sed -i '/host    all             all             0\.0\.0\.0\/0/d' "$hba_file"
        sed -i '/host    all             all             ::\/0/d' "$hba_file"
    fi

    log_info "External access configuration applied: enabled=$enable_external, method=$method"
}

# Execute main function
main "$@"